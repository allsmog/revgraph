"""Tests for multi-pass exploit analyzer."""

import json
from unittest.mock import MagicMock, patch

from revgraph.config.models import LLMConfig
from revgraph.llm.client import LLMClient
from revgraph.llm.exploit_analyzer import ExploitAnalyzer


def _make_client():
    config = LLMConfig(default_provider="openai", default_model="gpt-4o")
    return LLMClient(config)


@patch("litellm.completion")
def test_three_pass_pipeline_runs(mock_completion):
    """All three passes execute and results are structured correctly."""
    pass1_response = json.dumps([
        {
            "id": "oob-read-1",
            "type": "OOB read",
            "location": "scanner_naive2 @ 0x12b7",
            "description": "memcmp reads past buffer",
            "trigger": "option 3 with search_size=0x1000",
            "constraints": "search_size <= 0x1000",
            "read_or_write": "read",
            "survives": True,
        }
    ])
    pass2_response = json.dumps([
        {
            "id": "oob-read-1",
            "confirmed": True,
            "kill_reason": None,
            "primitive": "4095-byte OOB read oracle via memcmp",
            "prerequisite": "buffer filled with known data",
            "interacts_with": [],
        }
    ])
    pass3_response = json.dumps({
        "feasible": True,
        "strategy": "OOB memcmp oracle to leak libc, then ROP",
        "steps": [{"step": 1, "action": "fill buffer", "input": "A*4096", "effect": "known buffer", "leaks": None}],
        "missing_primitive": None,
        "exploit_skeleton": "# pwntools code here",
    })

    responses = [pass1_response, pass2_response, pass3_response]
    call_count = [0]

    def side_effect(**kwargs):
        mock_resp = MagicMock()
        mock_resp.choices = [MagicMock()]
        mock_resp.choices[0].message.content = responses[call_count[0]]
        mock_resp.usage.prompt_tokens = 100
        mock_resp.usage.completion_tokens = 50
        mock_resp.usage.total_tokens = 150
        call_count[0] += 1
        return mock_resp

    mock_completion.side_effect = side_effect

    client = _make_client()
    analyzer = ExploitAnalyzer(client)
    result = analyzer.analyze(
        name="scanner",
        architecture="x86-64",
        protections="PIE, NX, Partial RELRO, No canary",
        libc_version="GLIBC 2.31",
        disassembly="<scanner_naive2>:\n  ...",
    )

    assert mock_completion.call_count == 3
    assert len(result["identified"]) == 1
    assert result["identified"][0]["id"] == "oob-read-1"
    assert len(result["validated"]) == 1
    assert result["validated"][0]["confirmed"] is True
    assert result["chain"]["feasible"] is True
    assert result["chain"]["strategy"] == "OOB memcmp oracle to leak libc, then ROP"


@patch("litellm.completion")
def test_validation_confirms_frame_pointer_corruption(mock_completion):
    """Pass 2 confirms off-by-null that corrupts caller's saved RBP."""
    pass1_response = json.dumps([
        {
            "id": "off-by-null-1",
            "type": "saved frame pointer corruption",
            "location": "read_parameters @ 0x14d7",
            "description": "scanf %16s writes 17 bytes into 16-byte buffer, null overwrites saved RBP",
            "trigger": "16-char scanner name + valid size",
            "constraints": "name won't match scanner, but function continues regardless",
            "read_or_write": "write",
            "caller_impact": "main's RBP LSB nulled, all rbp-relative accesses shift",
            "survives": True,
        }
    ])
    pass2_response = json.dumps([
        {
            "id": "off-by-null-1",
            "confirmed": True,
            "kill_reason": None,
            "primitive": "1-byte null write to saved RBP → caller frame shift",
            "caller_impact": "main's local vars (pattern_ptr, size, scanner_idx, haystack) accessed at wrong offsets",
            "prerequisite": "know RBP value to predict shifted frame layout",
            "interacts_with": ["oob-read-1"],
        }
    ])
    pass3_response = json.dumps({
        "feasible": True,
        "strategy": "leak RBP via OOB oracle, then off-by-null to shift main frame, write via fgets to shifted haystack",
        "steps": [{"step": 1, "action": "leak stack", "input": "oracle query", "effect": "know RBP", "leaks": "saved RBP"}],
        "missing_primitive": None,
        "exploit_skeleton": "# pwntools exploit",
    })

    responses = [pass1_response, pass2_response, pass3_response]
    call_count = [0]

    def side_effect(**kwargs):
        mock_resp = MagicMock()
        mock_resp.choices = [MagicMock()]
        mock_resp.choices[0].message.content = responses[call_count[0]]
        mock_resp.usage.prompt_tokens = 100
        mock_resp.usage.completion_tokens = 50
        mock_resp.usage.total_tokens = 150
        call_count[0] += 1
        return mock_resp

    mock_completion.side_effect = side_effect

    client = _make_client()
    analyzer = ExploitAnalyzer(client)
    result = analyzer.analyze(
        name="scanner",
        architecture="x86-64",
        protections="PIE, NX, Partial RELRO, No canary",
        libc_version="GLIBC 2.31",
        disassembly="<read_parameters>:\n  ...",
    )

    # Off-by-null confirmed → all 3 passes run
    assert mock_completion.call_count == 3
    assert len(result["validated"]) == 1
    assert result["validated"][0]["confirmed"] is True
    assert "frame" in result["validated"][0]["primitive"].lower() or "RBP" in result["validated"][0]["primitive"]
    assert result["chain"]["feasible"] is True


@patch("litellm.completion")
def test_validation_kills_true_false_positive(mock_completion):
    """Pass 2 kills a vuln where the function actually exits before corruption is used."""
    pass1_response = json.dumps([
        {
            "id": "format-string-1",
            "type": "format string",
            "location": "print_output @ 0x1469",
            "description": "printf with user data",
            "trigger": "option 3",
            "constraints": "format string is a literal",
            "read_or_write": "both",
            "caller_impact": "none",
            "survives": True,
        }
    ])
    pass2_response = json.dumps([
        {
            "id": "format-string-1",
            "confirmed": False,
            "kill_reason": "printf uses hard-coded literal format '%d'. User data is the integer argument, not the format string.",
            "primitive": None,
            "caller_impact": None,
            "prerequisite": None,
            "interacts_with": [],
        }
    ])

    responses = [pass1_response, pass2_response]
    call_count = [0]

    def side_effect(**kwargs):
        mock_resp = MagicMock()
        mock_resp.choices = [MagicMock()]
        mock_resp.choices[0].message.content = responses[call_count[0]]
        mock_resp.usage.prompt_tokens = 100
        mock_resp.usage.completion_tokens = 50
        mock_resp.usage.total_tokens = 150
        call_count[0] += 1
        return mock_resp

    mock_completion.side_effect = side_effect

    client = _make_client()
    analyzer = ExploitAnalyzer(client)
    result = analyzer.analyze(
        name="scanner",
        architecture="x86-64",
        protections="PIE, NX, Partial RELRO, No canary",
        libc_version="GLIBC 2.31",
        disassembly="<print_output>:\n  ...",
    )

    # Correctly killed — no pass 3
    assert mock_completion.call_count == 2
    assert result["validated"][0]["confirmed"] is False
    assert result["chain"]["feasible"] is False


@patch("litellm.completion")
def test_no_vulns_found_skips_passes(mock_completion):
    """If pass 1 finds nothing, passes 2 and 3 are skipped."""
    mock_resp = MagicMock()
    mock_resp.choices = [MagicMock()]
    mock_resp.choices[0].message.content = "[]"
    mock_resp.usage.prompt_tokens = 50
    mock_resp.usage.completion_tokens = 5
    mock_resp.usage.total_tokens = 55
    mock_completion.return_value = mock_resp

    client = _make_client()
    analyzer = ExploitAnalyzer(client)
    result = analyzer.analyze(
        name="safe_binary",
        architecture="x86-64",
        protections="Full RELRO, canary, PIE, NX",
        libc_version="GLIBC 2.35",
        disassembly="main:\n  ret",
    )

    assert mock_completion.call_count == 1  # only pass 1
    assert result["identified"] == []
    assert result["validated"] == []
    assert result["chain"]["feasible"] is False


def test_parse_json_with_markdown_fences():
    """JSON parser handles markdown code fences."""
    raw = '```json\n[{"id": "test", "confirmed": true}]\n```'
    result = ExploitAnalyzer._parse_json_array(raw, "test")
    assert len(result) == 1
    assert result[0]["id"] == "test"


def test_parse_json_object_with_fences():
    """JSON object parser handles markdown fences."""
    raw = '```json\n{"feasible": false, "reason": "no write"}\n```'
    result = ExploitAnalyzer._parse_json_object(raw, "test")
    assert result["feasible"] is False


def test_parse_invalid_json_returns_empty():
    """Invalid JSON returns empty list/error dict."""
    assert ExploitAnalyzer._parse_json_array("not json", "test") == []
    result = ExploitAnalyzer._parse_json_object("not json", "test")
    assert result["feasible"] is False
