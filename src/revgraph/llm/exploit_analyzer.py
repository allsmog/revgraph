"""Multi-pass exploitation analysis using LLM.

Three-pass pipeline:
  1. IDENTIFY — find all potential vulnerabilities
  2. VALIDATE — adversarially check each one (kill false positives)
  3. CHAIN   — build a concrete exploitation plan from survivors
"""

from __future__ import annotations

import json
from typing import Any

from revgraph.llm.client import LLMClient
from revgraph.llm.prompts import EXPLOIT_CHAIN, EXPLOIT_IDENTIFY, EXPLOIT_VALIDATE
from revgraph.utils.logging import get_logger

log = get_logger(__name__)


class ExploitAnalyzer:
    """Run multi-pass exploit analysis on a binary."""

    def __init__(self, llm: LLMClient) -> None:
        self._llm = llm

    def analyze(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str,
        strings: list[str] | None = None,
        imports: list[str] | None = None,
    ) -> dict[str, Any]:
        """Run the full three-pass analysis pipeline.

        Returns a dict with keys:
            identified  — raw list from pass 1
            validated   — filtered list from pass 2
            chain       — exploitation plan from pass 3
        """
        log.info("exploit_analysis_start", binary=name)

        # --- Pass 1: Identify ---
        identified = self._pass_identify(
            name, architecture, protections, libc_version,
            disassembly, strings or [], imports or [],
        )
        log.info("exploit_pass1_done", vulns_found=len(identified))

        if not identified:
            return {"identified": [], "validated": [], "chain": {"feasible": False}}

        # --- Pass 2: Validate ---
        validated = self._pass_validate(
            name, architecture, protections, disassembly, identified,
        )
        confirmed = [v for v in validated if v.get("confirmed")]
        log.info(
            "exploit_pass2_done",
            confirmed=len(confirmed),
            killed=len(validated) - len(confirmed),
        )

        if not confirmed:
            return {
                "identified": identified,
                "validated": validated,
                "chain": {"feasible": False, "missing_primitive": "No confirmed vulnerabilities survived validation."},
            }

        # --- Pass 3: Chain ---
        chain = self._pass_chain(
            name, architecture, protections, libc_version,
            disassembly, confirmed,
        )
        log.info("exploit_pass3_done", feasible=chain.get("feasible"))

        return {
            "identified": identified,
            "validated": validated,
            "chain": chain,
        }

    def _pass_identify(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str,
        strings: list[str],
        imports: list[str],
    ) -> list[dict[str, Any]]:
        prompt = EXPLOIT_IDENTIFY.render(
            name=name,
            architecture=architecture,
            protections=protections,
            libc_version=libc_version,
            disassembly=disassembly,
            strings=strings,
            imports=imports,
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_array(raw, "identify")

    def _pass_validate(
        self,
        name: str,
        architecture: str,
        protections: str,
        disassembly: str,
        vulns: list[dict[str, Any]],
    ) -> list[dict[str, Any]]:
        prompt = EXPLOIT_VALIDATE.render(
            name=name,
            architecture=architecture,
            protections=protections,
            disassembly=disassembly,
            vulns_json=json.dumps(vulns, indent=2),
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_array(raw, "validate")

    def _pass_chain(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str,
        confirmed: list[dict[str, Any]],
    ) -> dict[str, Any]:
        prompt = EXPLOIT_CHAIN.render(
            name=name,
            architecture=architecture,
            protections=protections,
            libc_version=libc_version,
            disassembly=disassembly,
            confirmed_json=json.dumps(confirmed, indent=2),
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_object(raw, "chain")

    @staticmethod
    def _parse_json_array(raw: str, pass_name: str) -> list[dict[str, Any]]:
        """Extract a JSON array from LLM output, tolerating markdown fences."""
        raw = raw.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0]
        try:
            result = json.loads(raw)
            if isinstance(result, list):
                return result
        except json.JSONDecodeError:
            pass
        log.warning("json_parse_failed", pass_name=pass_name, raw_len=len(raw))
        return []

    @staticmethod
    def _parse_json_object(raw: str, pass_name: str) -> dict[str, Any]:
        """Extract a JSON object from LLM output."""
        raw = raw.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0]
        try:
            result = json.loads(raw)
            if isinstance(result, dict):
                return result
        except json.JSONDecodeError:
            pass
        log.warning("json_parse_failed", pass_name=pass_name, raw_len=len(raw))
        return {"feasible": False, "error": "Failed to parse chain output"}
