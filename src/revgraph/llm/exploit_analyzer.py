"""Multi-pass exploitation analysis using LLM.

Three-pass pipeline:
  1. IDENTIFY — find all potential vulnerabilities
  2. VALIDATE — adversarially check each one (kill false positives)
  3. CHAIN   — build a concrete exploitation plan from survivors

Supports two modes:
  - **Stuffed** (default): caller supplies disassembly/strings/imports inline
    via Jinja2 templates.  Used by the CLI local-binary path.
  - **Agentic**: if ``sha256`` and ``registry`` are provided, each pass uses
    a tool-calling loop so the model fetches data itself.
"""

from __future__ import annotations

import json
from typing import Any

from revgraph.agents.registry import ToolRegistry
from revgraph.llm.client import LLMClient
from revgraph.llm.prompts import (
    AGENT_EXPLOIT_CHAIN,
    AGENT_EXPLOIT_IDENTIFY,
    AGENT_EXPLOIT_VALIDATE,
    EXPLOIT_CHAIN,
    EXPLOIT_IDENTIFY,
    EXPLOIT_VALIDATE,
)
from revgraph.utils.logging import get_logger

log = get_logger(__name__)

_IDENTIFY_TOOLS = [
    "load_binary_info",
    "list_functions",
    "get_function_details",
    "get_function_strings",
    "get_function_imports",
    "get_function_callers",
    "get_function_callees",
    "get_basic_blocks",
    "get_instructions",
    "search_strings",
    "search_functions",
    "compute_bbr",
    "get_dangerous_functions",
]

_VALIDATE_TOOLS = [
    "get_function_details",
    "get_function_strings",
    "get_function_imports",
    "get_function_callers",
    "get_function_callees",
    "get_basic_blocks",
    "get_instructions",
]

_CHAIN_TOOLS = [
    "get_function_details",
    "get_function_strings",
    "get_function_imports",
    "get_function_callers",
    "get_function_callees",
    "get_basic_blocks",
    "get_instructions",
    "list_functions",
    "search_strings",
]


class ExploitAnalyzer:
    """Run multi-pass exploit analysis on a binary."""

    def __init__(
        self,
        llm: LLMClient,
        sha256: str | None = None,
        registry: ToolRegistry | None = None,
    ) -> None:
        self._llm = llm
        self._sha256 = sha256
        self._registry = registry

    @property
    def _agentic(self) -> bool:
        return self._sha256 is not None and self._registry is not None

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def analyze(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str = "",
        strings: list[str] | None = None,
        imports: list[str] | None = None,
    ) -> dict[str, Any]:
        """Run the full three-pass analysis pipeline.

        Returns a dict with keys:
            identified  — raw list from pass 1
            validated   — filtered list from pass 2
            chain       — exploitation plan from pass 3
        """
        log.info("exploit_analysis_start", binary=name, agentic=self._agentic)

        # --- Pass 1: Identify ---
        identified = self._pass_identify(
            name, architecture, protections, libc_version,
            disassembly, strings or [], imports or [],
        )
        log.info("exploit_pass1_done", vulns_found=len(identified))

        if not identified:
            return {"identified": [], "validated": [], "chain": {"feasible": False}}

        # --- Pass 2: Validate ---
        validated = self._pass_validate(
            name, architecture, protections, disassembly, identified,
        )
        confirmed = [v for v in validated if v.get("confirmed")]
        log.info(
            "exploit_pass2_done",
            confirmed=len(confirmed),
            killed=len(validated) - len(confirmed),
        )

        if not confirmed:
            return {
                "identified": identified,
                "validated": validated,
                "chain": {
                    "feasible": False,
                    "missing_primitive": "No confirmed vulnerabilities survived validation.",
                },
            }

        # --- Pass 3: Chain ---
        chain = self._pass_chain(
            name, architecture, protections, libc_version,
            disassembly, confirmed,
        )
        log.info("exploit_pass3_done", feasible=chain.get("feasible"))

        return {
            "identified": identified,
            "validated": validated,
            "chain": chain,
        }

    # ------------------------------------------------------------------
    # Pass implementations
    # ------------------------------------------------------------------

    def _pass_identify(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str,
        strings: list[str],
        imports: list[str],
    ) -> list[dict[str, Any]]:
        if self._agentic:
            return self._pass_identify_agentic(name, architecture, protections, libc_version)

        prompt = EXPLOIT_IDENTIFY.render(
            name=name,
            architecture=architecture,
            protections=protections,
            libc_version=libc_version,
            disassembly=disassembly,
            strings=strings,
            imports=imports,
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_array(raw, "identify")

    def _pass_validate(
        self,
        name: str,
        architecture: str,
        protections: str,
        disassembly: str,
        vulns: list[dict[str, Any]],
    ) -> list[dict[str, Any]]:
        if self._agentic:
            return self._pass_validate_agentic(name, architecture, protections, vulns)

        prompt = EXPLOIT_VALIDATE.render(
            name=name,
            architecture=architecture,
            protections=protections,
            disassembly=disassembly,
            vulns_json=json.dumps(vulns, indent=2),
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_array(raw, "validate")

    def _pass_chain(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        disassembly: str,
        confirmed: list[dict[str, Any]],
    ) -> dict[str, Any]:
        if self._agentic:
            return self._pass_chain_agentic(
                name, architecture, protections, libc_version, confirmed,
            )

        prompt = EXPLOIT_CHAIN.render(
            name=name,
            architecture=architecture,
            protections=protections,
            libc_version=libc_version,
            disassembly=disassembly,
            confirmed_json=json.dumps(confirmed, indent=2),
        )
        raw = self._llm.complete(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return self._parse_json_object(raw, "chain")

    # ------------------------------------------------------------------
    # Agentic pass implementations
    # ------------------------------------------------------------------

    def _pass_identify_agentic(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
    ) -> list[dict[str, Any]]:
        assert self._registry is not None and self._sha256 is not None
        messages = [
            {"role": "system", "content": AGENT_EXPLOIT_IDENTIFY},
            {
                "role": "user",
                "content": (
                    f"Binary: {name} ({architecture})\n"
                    f"Protections: {protections}\n"
                    f"Libc: {libc_version}\n"
                    f"SHA256: {self._sha256}\n\n"
                    "Explore the binary and identify ALL potential vulnerabilities."
                ),
            },
        ]
        tools = self._registry.get_tool_schemas_by_name(_IDENTIFY_TOOLS)
        executor = self._registry.make_tool_executor()

        raw = self._llm.tool_loop(
            messages=messages,
            tools=tools,
            tool_executor=executor,
            temperature=0.1,
            max_iterations=20,
        )
        return self._parse_json_array(raw, "identify")

    def _pass_validate_agentic(
        self,
        name: str,
        architecture: str,
        protections: str,
        vulns: list[dict[str, Any]],
    ) -> list[dict[str, Any]]:
        assert self._registry is not None and self._sha256 is not None
        messages = [
            {"role": "system", "content": AGENT_EXPLOIT_VALIDATE},
            {
                "role": "user",
                "content": (
                    f"Binary: {name} ({architecture})\n"
                    f"Protections: {protections}\n"
                    f"SHA256: {self._sha256}\n\n"
                    f"Claimed vulnerabilities:\n```json\n{json.dumps(vulns, indent=2)}\n```\n\n"
                    "Re-examine the code via tools and DISPROVE or CONFIRM each."
                ),
            },
        ]
        tools = self._registry.get_tool_schemas_by_name(_VALIDATE_TOOLS)
        executor = self._registry.make_tool_executor()

        raw = self._llm.tool_loop(
            messages=messages,
            tools=tools,
            tool_executor=executor,
            temperature=0.1,
            max_iterations=15,
        )
        return self._parse_json_array(raw, "validate")

    def _pass_chain_agentic(
        self,
        name: str,
        architecture: str,
        protections: str,
        libc_version: str,
        confirmed: list[dict[str, Any]],
    ) -> dict[str, Any]:
        assert self._registry is not None and self._sha256 is not None
        messages = [
            {"role": "system", "content": AGENT_EXPLOIT_CHAIN},
            {
                "role": "user",
                "content": (
                    f"Binary: {name} ({architecture})\n"
                    f"Protections: {protections}\n"
                    f"Libc: {libc_version}\n"
                    f"SHA256: {self._sha256}\n\n"
                    "Confirmed vulnerabilities:\n"
                    f"```json\n{json.dumps(confirmed, indent=2)}\n```\n\n"
                    "Build a concrete exploitation chain."
                ),
            },
        ]
        tools = self._registry.get_tool_schemas_by_name(_CHAIN_TOOLS)
        executor = self._registry.make_tool_executor()

        raw = self._llm.tool_loop(
            messages=messages,
            tools=tools,
            tool_executor=executor,
            temperature=0.1,
            max_iterations=15,
        )
        return self._parse_json_object(raw, "chain")

    # ------------------------------------------------------------------
    # JSON parsing helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _parse_json_array(raw: str, pass_name: str) -> list[dict[str, Any]]:
        """Extract a JSON array from LLM output, tolerating markdown fences."""
        raw = raw.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0]
        try:
            result = json.loads(raw)
            if isinstance(result, list):
                return result
        except json.JSONDecodeError:
            pass
        log.warning("json_parse_failed", pass_name=pass_name, raw_len=len(raw))
        return []

    @staticmethod
    def _parse_json_object(raw: str, pass_name: str) -> dict[str, Any]:
        """Extract a JSON object from LLM output."""
        raw = raw.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0]
        try:
            result = json.loads(raw)
            if isinstance(result, dict):
                return result
        except json.JSONDecodeError:
            pass
        log.warning("json_parse_failed", pass_name=pass_name, raw_len=len(raw))
        return {"feasible": False, "error": "Failed to parse chain output"}
