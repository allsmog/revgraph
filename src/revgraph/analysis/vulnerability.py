"""Shared vulnerable code tracing across binaries."""

from __future__ import annotations

from typing import Any

from neo4j import Driver

from revgraph.utils.logging import get_logger

log = get_logger(__name__)

DANGEROUS_APIS = [
    "strcpy", "strcat", "sprintf", "vsprintf", "gets", "scanf",
    "sscanf", "fscanf", "realpath", "getwd", "streadd", "strecpy",
    "strtrns", "system", "popen", "exec", "execl", "execle",
    "execlp", "execv", "execve", "execvp", "dlopen",
]


def find_dangerous_functions(
    driver: Driver, sha256: str
) -> list[dict[str, Any]]:
    """Find functions that reference dangerous APIs."""
    with driver.session() as session:
        result = session.run(
            "MATCH (f:Function {binary_sha256: $sha256})-[:REFERENCES_IMPORT]->(i:Import) "
            "WHERE i.name IN $dangerous "
            "RETURN f.name AS function_name, f.address AS address, "
            "collect(i.name) AS dangerous_imports, f.decompiled_code AS code",
            sha256=sha256,
            dangerous=DANGEROUS_APIS,
        )
        return [dict(r) for r in result]


def trace_vulnerable_callers(
    driver: Driver, sha256: str, func_address: int, max_depth: int = 5
) -> list[dict[str, Any]]:
    """Trace all callers of a vulnerable function up to max_depth."""
    with driver.session() as session:
        result = session.run(
            "MATCH path = (caller:Function)-[:CALLS*1.." + str(max_depth) + "]->"
            "(f:Function {address: $address, binary_sha256: $sha256}) "
            "RETURN [n IN nodes(path) | {name: n.name, address: n.address}] AS call_chain, "
            "length(path) AS depth "
            "ORDER BY depth",
            address=func_address,
            sha256=sha256,
        )
        return [dict(r) for r in result]


def find_cross_binary_vulnerable(
    driver: Driver, import_name: str
) -> list[dict[str, Any]]:
    """Find all functions across all binaries that use a dangerous import."""
    with driver.session() as session:
        result = session.run(
            "MATCH (f:Function)-[:REFERENCES_IMPORT]->(i:Import {name: $name}) "
            "MATCH (b:BinaryFile {sha256: f.binary_sha256}) "
            "RETURN b.name AS binary_name, b.sha256 AS binary_sha256, "
            "f.name AS function_name, f.address AS address "
            "ORDER BY b.name, f.name",
            name=import_name,
        )
        return [dict(r) for r in result]


def vulnerability_surface(
    driver: Driver, sha256: str
) -> dict[str, Any]:
    """Compute a vulnerability surface summary for a binary."""
    dangerous = find_dangerous_functions(driver, sha256)

    # Count by API
    api_counts: dict[str, int] = {}
    for func in dangerous:
        for api in func.get("dangerous_imports", []):
            api_counts[api] = api_counts.get(api, 0) + 1

    # Functions with high BBR that are also dangerous
    high_risk = []
    with driver.session() as session:
        for func in dangerous:
            result = session.run(
                "MATCH (f:Function {address: $addr, binary_sha256: $sha256})"
                "-[:CONTAINS]->(bb:BasicBlock) "
                "WHERE bb.bbr_score IS NOT NULL "
                "RETURN max(bb.bbr_score) AS max_bbr",
                addr=func["address"],
                sha256=sha256,
            )
            record = result.single()
            bbr = record["max_bbr"] if record else None
            if bbr and bbr > 0.01:  # Arbitrary threshold
                high_risk.append({**func, "max_bbr": bbr})

    return {
        "total_dangerous_functions": len(dangerous),
        "api_usage": api_counts,
        "high_risk_functions": sorted(high_risk, key=lambda x: x.get("max_bbr", 0), reverse=True),
        "dangerous_functions": dangerous,
    }
